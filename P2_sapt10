#include<opencv2/opencv.hpp>
#include<opencv2/core/core.hpp>
#include<opencv2/highgui/highgui.hpp>
#include <iostream>
#include<math.h>

using namespace std;
using namespace cv;

Mat image = imread("ema.jpg", CV_8UC1);
int height = image.rows;
int width = image.cols;
int _stride = image.step;
float *theta = (float *)malloc((height)*(width) * sizeof(float));

Mat Salt_and_pepper(Mat original) {
	Mat zgomot = original.clone();
	Mat imagine_cu_zgomot = original.clone();
	uint8_t* purici = zgomot.data;
	uint8_t* myData_s_p = imagine_cu_zgomot.data;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			purici[i * _stride + j] = rand() % 256;
		}
	}
	for (int i = 0; i < height; i++)
	{
		for (int j = 0; j < width; j++)
		{
			if (purici[i* _stride + j] > 250) {
				myData_s_p[i * _stride + j] = 255;
			}
			if (purici[i * _stride + j] < 5)
				myData_s_p[i * _stride + j] = 0;
		}
	}
	imshow("Salt&Pepper", imagine_cu_zgomot);
	return imagine_cu_zgomot;
}

Mat Filtru_median(Mat image) {
	int vecini[9];
	Mat copie = image.clone();
	uint8_t* myData_s_p = copie.data;
	uint8_t* myData_original = image.data;
	for (int i = 1; i < height - 1; i++)
	{
		for (int j = 1; j < width - 1; j++)
		{
			vecini[0] = myData_original[(i - 1)*_stride + j - 1];
			vecini[1] = myData_original[(i - 1)*_stride + j];
			vecini[2] = myData_original[(i - 1)*_stride + j + 1];
			vecini[3] = myData_original[i *_stride + j - 1];
			vecini[4] = myData_original[i *_stride + j];
			vecini[5] = myData_original[i *_stride + j + 1];
			vecini[6] = myData_original[(i + 1)*_stride + j - 1];
			vecini[7] = myData_original[(i + 1)*_stride + j];
			vecini[8] = myData_original[(i + 1)*_stride + j + 1];
			for (int v = 0; v < 8; v++) {
				for (int w = v + 1; w < 8; w++) {
					if (vecini[v] > vecini[w]) {
						int aux = vecini[v];
						vecini[v] = vecini[w];
						vecini[w] = aux;
					}
				}
			}
			myData_s_p[i * _stride + j] = vecini[4];
		}


	}
	imshow("Filtru median", copie);
	return copie;
}


Mat Filtru_gauss(Mat image) {
	Mat gauss = image.clone();
	uint8_t* original = image.data;
	float sigma = 1.2;
	uint8_t* element_gauss = gauss.data;
	float *kernel_gauss = (float *)malloc((dim)*(dim) * sizeof(float));
	int k = (dim - 1) / 2;
	for (int i = 0; i < dim; i++) {
		for (int j = 0; j < dim; j++) {
			kernel_gauss[i *(_stride)+j] = exp(-((i - k) * (i - k) + (j - k) * (j - k)) / (2 * sigma*sigma)) / (2 * 3.14*sigma*sigma);
		}
	}
	//verificare kernel
	float suma_totala = 0;
	for (int i = 0; i < dim; i++) {
		for (int j = 0; j < dim; j++) {
			cout << kernel_gauss[i * _stride + j] << " ";
			suma_totala += kernel_gauss[i * _stride + j];
		}
		cout << endl;
	}
	cout << suma_totala << endl;
	for (int i = k; i < height - k; i++)
	{
		for (int j = k; j < width - k; j++)
		{
			float suma = 0;
			//element_gauss[i * _stride + j] = original[(i - 2) * _stride + (j - 2)] * kernel_gauss[0] + original[(i - 2) * _stride + (j - 1)] * kernel_gauss[0 * _stride + 1] + original[(i - 2) * _stride + j] * kernel_gauss[0 * _stride + 2] + original[(i - 2) * _stride + (j + 1)] * kernel_gauss[0 * _stride + 3] + original[(i - 2) * _stride + (j + 2)] * kernel_gauss[0 * _stride + 4] + original[(i - 1) * _stride + (j - 2)] * kernel_gauss[1 * _stride + 0] + original[(i - 1) * _stride + (j - 1)] * kernel_gauss[1 * _stride + 1] + original[(i - 1) * _stride + j] * kernel_gauss[1 * _stride + 2] + original[(i - 1) * _stride + (j + 1)] * kernel_gauss[1 * _stride + 3] + original[(i - 1) * _stride + (j + 2)] * kernel_gauss[1 * _stride + 4] + original[i * _stride + (j - 2)] * kernel_gauss[2 * _stride + 0] + original[i * _stride + (j - 1)] * kernel_gauss[2 * _stride + 1] + original[i  * _stride + j] * kernel_gauss[2 * _stride + 2] + original[i * _stride + (j + 1)] * kernel_gauss[2 * _stride + 3] + original[i * _stride + (j + 2)] * kernel_gauss[2 * _stride + 4] + original[(i + 1) * _stride + (j - 2)] * kernel_gauss[3 * _stride + 0] + original[(i + 1) * _stride + (j - 1)] * kernel_gauss[3 * _stride + 1] + original[(i + 1) * _stride + j] * kernel_gauss[3 * _stride + 2] + original[(i + 1) * _stride + (j + 1)] * kernel_gauss[3 * _stride + 3] + original[(i + 1) * _stride + (j + 2)] * kernel_gauss[3 * _stride + 4] + original[(i + 2) * _stride + (j - 2)] * kernel_gauss[4 * _stride + 0] + original[(i + 2) * _stride + (j - 1)] * kernel_gauss[4 * _stride + 1] + original[(i + 2) * _stride + j] * kernel_gauss[4 * _stride + 2] + original[(i + 2) * _stride + (j + 1)] * kernel_gauss[4 * _stride + 3] + original[(i + 2) * _stride + (j + 2)] * kernel_gauss[4 * _stride + 4];
			for (int z = 0; z < dim; z++) {
				for (int w = 0; w < dim; w++) {
					suma += kernel_gauss[z*_stride + w] * original[(i - k + z)*_stride + j - k + w];
				}
			}
			
			element_gauss[i * _stride + j] = suma;
		}
	}
	imshow("Filtru gauss", gauss);
	return gauss;
}


Mat Gradinet_theta(Mat image) {
	Mat gradient = image.clone();
	uint8_t* element_gauss = gradient.data;
	Mat Ix = image.clone();
	Mat Iy = image.clone();
	uint8_t* myDatax = Ix.data;
	uint8_t* myDatay = Iy.data;
	Mat modul_G = image.clone();
	uint8_t* myDataG = modul_G.data;
	int Kx[3][3] = { {-1,0,1},{-2,0,2},{-1,0,1} };
	int Ky[3][3] = { {1,2,1},{0,0,0},{-1,-2,-1} };
	int X;
	int Y;
	int sum;
	for (int i = 1; i < height - 1; i++)
	{
		for (int j = 1; j < width - 1; j++) {
			X = element_gauss[(i - 1)*_stride + j - 1] * Kx[0][0] + element_gauss[(i - 1)*_stride + j] * Kx[0][1] + element_gauss[(i - 1)*_stride + j + 1] * Kx[0][2] + element_gauss[(i)*_stride + j - 1] * Kx[1][0] + element_gauss[(i)*_stride + j] * Kx[1][1] + element_gauss[(i)*_stride + j + 1] * Kx[1][2] + element_gauss[(i + 1)*_stride + j - 1] * Kx[2][0] + element_gauss[(i + 1)*_stride + j] * Kx[2][1] + element_gauss[(i + 1)*_stride + j + 1] * Kx[2][2];
			Y = element_gauss[(i - 1)*_stride + j - 1] * Ky[0][0] + element_gauss[(i - 1)*_stride + j] * Ky[0][1] + element_gauss[(i - 1)*_stride + j + 1] * Ky[0][2] + element_gauss[(i)*_stride + j - 1] * Ky[1][0] + element_gauss[(i)*_stride + j] * Ky[1][1] + element_gauss[(i)*_stride + j + 1] * Ky[1][2] + element_gauss[(i + 1)*_stride + j - 1] * Ky[2][0] + element_gauss[(i + 1)*_stride + j] * Ky[2][1] + element_gauss[(i + 1)*_stride + j + 1] * Ky[2][2];
			sum= sqrt(X * X + Y * Y);
			if (sum > 255) {
				sum = 255;
			}
			if (sum < 0) {
				sum = 0;
			}
			myDataG[i*_stride + j] = sum;
		}
	}
	imshow("gradientului", modul_G);

	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			int x = myDatax[i*_stride + j] + 1;
			int y = myDatay[i*_stride + j];
			theta[i*_stride + j] = atan(y / x) * 180 / 3.14;
			if (theta[i*_stride + j] < 0) {
				theta[i*_stride + j] += 180;
			}
		}
	}
	int max = 0;
	for (int i = 3; i < height-3; i++) {
		for (int j = 3; j < width-3; j++) {
			if (myDataG[i*_stride + j] > max) {
				max = myDataG[i*_stride + j];
			}
		}
	}
	imshow("grd2", modul_G);

	return modul_G;
}
Mat Max_supr(Mat image) {
	Mat img= image.clone();
	Mat max_suppersion = image.clone();
	uint8_t* myDataSupr = max_suppersion.data;
	uint8_t* imag = img.data;
	for (int i = 0; i < height; i++) {
		for (int j = 1; j < width ; j++) {
			myDataSupr[i*_stride + j] = 0;
		}
	}
	for (int i = 1; i < height - 1; i++) {
		for (int j = 1; j < width - 1; j++) {
			int st, dr;
			if (0 <= theta[i*_stride + j] < 22.5 || 157.5 <= theta[i*_stride + j] <= 180) {
				st = imag[i*_stride + j - 1];
				dr = imag[i*_stride + j + 1];
			}
			else if (22.5 <= theta[i*_stride + j] < 67.5) {
				st = imag[(i + 1)*_stride + j - 1];
				dr = imag[(i + 1)*_stride + j + 1];
			}
			else if (67.5 <= theta[i*_stride + j] < 122.5) {
				st = imag[(i - 1)*_stride + j];
				dr = imag[(i + 1)*_stride + j];
			}
			else if (122.5 <= theta[i*_stride + j] < 157.5) {
				st = imag[(i - 1)*_stride + j - 1];
				dr = imag[(i + 1)*_stride + j + 1];
			}
			if (imag[i *_stride + j] >= st && imag[i *_stride + j] >= dr) 
				myDataSupr[i*_stride + j] = imag[i*_stride + j];
			else
				myDataSupr[i*_stride + j] = 0;
		}
	}
	imshow("Suppression", max_suppersion);
	return max_suppersion;
}

Mat Double_thrs(Mat image) {
	Mat res = image.clone();
	uint8_t* rez = res.data;
	uint8_t* myDataSupr = image.data;
	float lowtreshholdratio = 0.05, hightreshholdratio = 0.09;
	float hightreshhold, lowtreshhold;
	uint8_t weak = 25, strong = 255;
	int max = 0;
	for (int i = 0; i < height; i++) {
		for (int j = 1; j < width; j++) {
			rez[i*_stride + j] = 0;
		}
	}
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			if (myDataSupr[i * _stride + j] > max)
				max = myDataSupr[i * _stride + j];
		}
	}
	hightreshhold = max * hightreshholdratio;
	lowtreshhold = hightreshhold * lowtreshholdratio;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			rez[i * _stride + j] = 0;
		}
	}
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			if (myDataSupr[i * _stride + j] > hightreshhold)
				rez[i * _stride + j] = strong;
			else
				if (myDataSupr[i * _stride + j] < hightreshhold && myDataSupr[i * _stride + j] > lowtreshhold)
					rez[i * _stride + j] = weak;
		}
	}
	imshow("res", res);
	return res;
}

Mat Edge_tracking(Mat image) {
	Mat histerezis = image.clone();
	Mat max_suppersion = image.clone();
	int weak = 25;
	int strong = 255;
	uint8_t*h_data = histerezis.data;
	for (int i = 1; i < height-1; i++) {
		for (int j = 1; j < width-1; j++) {
			if (h_data[i*_stride + j] == weak) {
				if (h_data[(i + 1)*_stride + j - 1] == strong || h_data[(i + 1)*_stride + j] == strong || h_data[(i + 1)*_stride + j + 1] == strong || h_data[(i)*_stride + j - 1] == strong || h_data[(i)*_stride + j+1] == strong || h_data[(i-1)*_stride + j - 1] == strong || h_data[(i - 1)*_stride + j ] == strong || h_data[(i - 1)*_stride + j+1])
					h_data[i*_stride + j] == strong;
			}
			else
				h_data[i*_stride + j] == 0;
		}
	}
	imshow("final", histerezis);
	return histerezis;
}
int main()
{

	imshow("Imaginea initiala", image);
	uint8_t* original = image.data;

	Mat sare_piper = Salt_and_pepper(image);
	Mat reparere = Filtru_median(sare_piper);
	Mat gauss = Filtru_gauss(image);
	Mat gragient = Gradinet_theta(gauss);
	Mat max_s = Max_supr(gragient);
	Mat Double_threshold = Double_thrs(max_s);
	Mat Edge_Tracking_by_Hysteresis = Edge_tracking(Double_threshold);
	waitKey(0);
}


