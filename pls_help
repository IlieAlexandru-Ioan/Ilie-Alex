#include<opencv2/opencv.hpp>
#include<opencv2/core/core.hpp>
#include<opencv2/highgui/highgui.hpp>
#include <iostream>
#include<math.h>
using namespace std;
using namespace cv;
int main()
{
	Mat image = imread("emaa.jpg", CV_8UC1);
	Mat Ix = image.clone();
	Mat Iy = image.clone();
	imshow("Imaginea initiala", image);
	int width = Ix.cols;
	int height = Ix.rows;
	int _stride = Ix.step;
	uint8_t* original = image.data;
	uint8_t* myDatax = Ix.data;
	uint8_t* myDatay = Iy.data;
	uint8_t* myData = image.data;//lucram pe matricea originala
	//in case cols != strides
	//parcurgere in interiorul pozei fara a modifica 
	Mat res = image.clone();
	uint8_t* rez = res.data;

	Mat copie_salt = image.clone();
	uint8_t* elemente_sare_piper = copie_salt.data;
	Mat salt = image.clone();
	uint8_t* myData_s_p = salt.data;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			elemente_sare_piper[i * _stride + j] = rand() % 256;
		}
	}
	for (int i = 0; i < height; i++)
	{
		for (int j = 0; j < width; j++)
		{
			if (elemente_sare_piper[i* _stride + j] > 250) {
				myData_s_p[i * _stride + j] = 255;
			}
			if (elemente_sare_piper[i * _stride + j] < 5)
				myData_s_p[i * _stride + j] = 0;
		}
	}
	imshow("imagine cu zgomot", salt);
	int vecini[9];

	for (int i = 1; i < height - 1; i++)
	{
		for (int j = 1; j < width - 1; j++)
		{
			if (myData_s_p[i*_stride + j] >= 200 || myData_s_p[i*_stride + j] <= 50) {
				//uint8_t val = myData[i * _stride + j];
				vecini[0] = myData_s_p[(i - 1)*_stride + j - 1];
				vecini[1] = myData_s_p[(i - 1)*_stride + j];
				vecini[2] = myData_s_p[(i - 1)*_stride + j + 1];
				vecini[3] = myData_s_p[i *_stride + j - 1];
				vecini[4] = myData_s_p[i *_stride + j];
				vecini[5] = myData_s_p[i *_stride + j + 1];
				vecini[6] = myData_s_p[(i + 1)*_stride + j - 1];
				vecini[7] = myData_s_p[(i + 1)*_stride + j];
				vecini[8] = myData_s_p[(i + 1)*_stride + j + 1];
				for (int v = 0; v < 8; v++) {
					for (int w = v + 1; w < 8; w++) {
						if (vecini[v] > vecini[w]) {
							int aux = vecini[v];
							vecini[v] = vecini[w];
							vecini[w] = aux;
						}
					}
				}
				myData_s_p[i * _stride + j] = vecini[4];
			}

		}
	}
	imshow("Imagine dupa filtru median", salt);

	//--------------------------------------
	Mat gauss = image.clone();
	float sigma = 1.4;
	uint8_t* element_gauss = gauss.data;
	float kernel_gauss[5][5], k = 2;
	for (int i = 1; i <= 5; i++) {
		for (int j = 1; j <= 5; j++) {
			kernel_gauss[i - 1][j - 1] = exp(-((i - k - 1) * (i - k - 1) + (j - k - 1) * (j - k - 1)) / (2 * sigma*sigma)) / (2 * 3.14*sigma*sigma);
		}
	}
	//verificare kernel
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 5; j++) {
			cout << kernel_gauss[i][j] << " ";
		}
		cout << endl;
	}
	for (int i = 2; i < height - 2; i++)
	{
		for (int j = 2; j < width - 2; j++)
		{
			element_gauss[i * _stride + j] = original[(i - 2) * _stride + (j - 2)] * kernel_gauss[0][0] + original[(i - 2) * _stride + (j - 1)] * kernel_gauss[0][1] + original[(i - 2) * _stride + j] * kernel_gauss[0][2] + original[(i - 2) * _stride + (j + 1)] * kernel_gauss[0][3] + original[(i - 2) * _stride + (j + 2)] * kernel_gauss[0][4] + original[(i - 1) * _stride + (j - 2)] * kernel_gauss[1][0] + original[(i - 1) * _stride + (j - 1)] * kernel_gauss[1][1] + original[(i - 1) * _stride + j] * kernel_gauss[1][2] + original[(i - 1) * _stride + (j + 1)] * kernel_gauss[1][3] + original[(i - 1) * _stride + (j + 2)] * kernel_gauss[1][4] + original[i * _stride + (j - 2)] * kernel_gauss[2][0] + original[i * _stride + (j - 1)] * kernel_gauss[2][1] + original[i  * _stride + j] * kernel_gauss[2][2] + original[i * _stride + (j + 1)] * kernel_gauss[2][3] + original[i * _stride + (j + 2)] * kernel_gauss[2][4] + original[(i + 1) * _stride + (j - 2)] * kernel_gauss[3][0] + original[(i + 1) * _stride + (j - 1)] * kernel_gauss[3][1] + original[(i + 1) * _stride + j] * kernel_gauss[3][2] + original[(i + 1) * _stride + (j + 1)] * kernel_gauss[3][3] + original[(i + 1) * _stride + (j + 2)] * kernel_gauss[3][4] + original[(i + 2) * _stride + (j - 2)] * kernel_gauss[4][0] + original[(i + 2) * _stride + (j - 1)] * kernel_gauss[4][1] + original[(i + 2) * _stride + j] * kernel_gauss[4][2] + original[(i + 2) * _stride + (j + 1)] * kernel_gauss[4][3] + original[(i + 2) * _stride + (j + 2)] * kernel_gauss[4][4];
		}
	}
	imshow("Filtru gauss", gauss);

	int Kx[3][3] = { {-1,0,1},{-2,0,2},{-1,0,1} };
	int Ky[3][3] = { {1,2,1},{0,0,0},{-1,-2,-1} };


	for (int i = 1; i < height - 1; i++)
	{
		for (int j = 1; j < width - 1; j++) {
			myDatax[i*_stride + j] = element_gauss[(i - 1)*_stride + j - 1] * Kx[0][0] + element_gauss[(i - 1)*_stride + j] * Kx[0][1] + element_gauss[(i - 1)*_stride + j + 1] * Kx[0][2] + element_gauss[(i)*_stride + j - 1] * Kx[1][0] + element_gauss[(i)*_stride + j] * Kx[1][1] + element_gauss[(i)*_stride + j + 1] * Kx[1][2] + element_gauss[(i + 1)*_stride + j - 1] * Kx[2][0] + element_gauss[(i + 1)*_stride + j] * Kx[2][1] + element_gauss[(i + 1)*_stride + j + 1] * Kx[2][2];
			myDatay[i*_stride + j] = element_gauss[(i - 1)*_stride + j - 1] * Ky[0][0] + element_gauss[(i - 1)*_stride + j] * Ky[0][1] + element_gauss[(i - 1)*_stride + j + 1] * Ky[0][2] + element_gauss[(i)*_stride + j - 1] * Ky[1][0] + element_gauss[(i)*_stride + j] * Ky[1][1] + element_gauss[(i)*_stride + j + 1] * Ky[1][2] + element_gauss[(i + 1)*_stride + j - 1] * Ky[2][0] + element_gauss[(i + 1)*_stride + j] * Ky[2][1] + element_gauss[(i + 1)*_stride + j + 1] * Ky[2][2];
		}
	}
	cout << width << " " << height << endl;
	Mat modul_G = image.clone();
	float t[300][234];
	uint8_t* myDataG = modul_G.data;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			myDataG[i*_stride + j] = sqrt(myDatax[i*_stride + j] * myDatax[i*_stride + j] + myDatay[i*_stride + j] * myDatay[i*_stride + j]);
			int x = myDatax[i*_stride + j] + 1;
			int y = myDatay[i*_stride + j];
			t[i][j] = atan(y / x) * 180 / 3.14;
		}
	}
	int max = 0;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			if (myDataG[i*_stride + j] > max) {
				max = myDataG[i*_stride + j];
			}
		}
	}
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			myDataG[i*_stride + j] = (myDataG[i*_stride + j] / 253) * 255;//merge cu 235 mai bine in loc de max
		}
	}
	imshow("Imagine dupa Ox", Ix);
	imshow("Imagine dupa Oy", Iy);
	imshow("gradientului", modul_G);
	cout << max << endl;//e 255
	cout << t[100][40];



	Mat max_suppersion = modul_G.clone();
	imshow("test", max_suppersion);
	uint8_t* myDataSupr = max_suppersion.data;
	for (int i = 1; i < height - 1; i++) {//marginile o sa le facem separat
		for (int j = 1; j < width - 1; j++) {
			int st, dr;
			if (0 <= t[i][j] < 22.5 || 157.5 <= t[i][j] <= 180) {
				st = myDataSupr[i*_stride + j - 1];
				dr = myDataSupr[i*_stride + j + 1];
			}
			else if (22.5 <= t[i][j] < 67.5) {
				st = myDataSupr[(i + 1)*_stride + j - 1];
				dr = myDataSupr[(i + 1)*_stride + j + 1];
			}
			else if (67.5 <= t[i][j] < 122.5) {
				st = myDataSupr[(i - 1)*_stride + j];
				dr = myDataSupr[(i + 1)*_stride + j];
			}
			else if (122.5 <= t[i][j] < 157.5) {
				st = myDataSupr[(i - 1)*_stride + j - 1];
				dr = myDataSupr[(i + 1)*_stride + j + 1];
			}
			if (myDataSupr[i *_stride + j] <= st || myDataSupr[i *_stride + j] <= dr) {
				myDataSupr[i*_stride + j] = 0;
			}
		}
	}
	imshow("Suppression", max_suppersion);




	float lowtreshholdratio = 0.05, hightreshholdratio = 0.09;
	float hightreshhold, lowtreshhold;
	uint8_t weak = 25, strong = 255;
	max = 0;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			if (myDataSupr[i * _stride + j] > max)
				max = myDataSupr[i * _stride + j];
		}
	}
	hightreshhold = max * hightreshholdratio;
	lowtreshhold = hightreshhold * lowtreshholdratio;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			rez[i * _stride + j] = 0;
		}
	}
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			if (myDataSupr[i * _stride + j] > hightreshhold)
				rez[i * _stride + j] = strong;
			else
				if (myDataSupr[i * _stride + j] < hightreshhold && myDataSupr[i * _stride + j] > lowtreshhold)
					rez[i * _stride + j] = weak;
		}
	}
	imshow("res", res);



	Mat histerezis = res.clone();
	uint8_t*h_data = histerezis.data;
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			if (h_data[i*_stride + j] == weak) {
				if (h_data[(i - 1)*_stride + j - 1] == strong || h_data[(i - 1)*_stride + j] == strong || h_data[(i - 1)*_stride + j + 1] == strong || h_data[(i)*_stride + j - 1] == strong || h_data[(i)*_stride + j] == strong || h_data[(i)*_stride + j + 1] == strong || h_data[(i + 1)*_stride + j - 1] == strong || h_data[(i + 1)*_stride + j] == strong || h_data[(i + 1)*_stride + j + 1] == strong)
					h_data[i*_stride + j] == strong;
			}
			else
				h_data[i*_stride + j] == 0;
		}
	}
	imshow("final", histerezis);
	waitKey(0);
}

